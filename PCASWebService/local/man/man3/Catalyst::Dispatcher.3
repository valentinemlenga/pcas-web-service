.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Dispatcher 3"
.TH Catalyst::Dispatcher 3 "2010-05-01" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
Catalyst::Dispatcher \- The Catalyst Dispatcher
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Catalyst.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the class that maps public urls to actions in your Catalyst
application based on the attributes you set.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
Construct a new dispatcher.
.Sh "$self\->preload_dispatch_types"
.IX Subsection "$self->preload_dispatch_types"
An arrayref of pre-loaded dispatchtype classes
.PP
Entries are considered to be available as \f(CW\*(C`Catalyst::DispatchType::CLASS\*(C'\fR
To use a custom class outside the regular \f(CW\*(C`Catalyst\*(C'\fR namespace, prefix
it with a \f(CW\*(C`+\*(C'\fR, like so:
.PP
.Vb 1
\&    +My::Dispatch::Type
.Ve
.Sh "$self\->postload_dispatch_types"
.IX Subsection "$self->postload_dispatch_types"
An arrayref of post-loaded dispatchtype classes
.PP
Entries are considered to be available as \f(CW\*(C`Catalyst::DispatchType::CLASS\*(C'\fR
To use a custom class outside the regular \f(CW\*(C`Catalyst\*(C'\fR namespace, prefix
it with a \f(CW\*(C`+\*(C'\fR, like so:
.PP
.Vb 1
\&    +My::Dispatch::Type
.Ve
.Sh "$self\->dispatch($c)"
.IX Subsection "$self->dispatch($c)"
Delegate the dispatch to the action that matched the url, or return a
message about unknown resource
.ie n .Sh "$self\->visit( $c\fP, \f(CW$command [, \e@arguments ] )"
.el .Sh "$self\->visit( \f(CW$c\fP, \f(CW$command\fP [, \e@arguments ] )"
.IX Subsection "$self->visit( $c, $command [, @arguments ] )"
Documented in Catalyst
.ie n .Sh "$self\->go( $c\fP, \f(CW$command [, \e@arguments ] )"
.el .Sh "$self\->go( \f(CW$c\fP, \f(CW$command\fP [, \e@arguments ] )"
.IX Subsection "$self->go( $c, $command [, @arguments ] )"
Documented in Catalyst
.ie n .Sh "$self\->forward( $c\fP, \f(CW$command [, \e@arguments ] )"
.el .Sh "$self\->forward( \f(CW$c\fP, \f(CW$command\fP [, \e@arguments ] )"
.IX Subsection "$self->forward( $c, $command [, @arguments ] )"
Documented in Catalyst
.ie n .Sh "$self\->detach( $c\fP, \f(CW$command [, \e@arguments ] )"
.el .Sh "$self\->detach( \f(CW$c\fP, \f(CW$command\fP [, \e@arguments ] )"
.IX Subsection "$self->detach( $c, $command [, @arguments ] )"
Documented in Catalyst
.Sh "$self\->prepare_action($c)"
.IX Subsection "$self->prepare_action($c)"
Find an dispatch type that matches \f(CW$c\fR\->req\->path, and set args from it.
.ie n .Sh "$self\->get_action( $action\fP, \f(CW$namespace )"
.el .Sh "$self\->get_action( \f(CW$action\fP, \f(CW$namespace\fP )"
.IX Subsection "$self->get_action( $action, $namespace )"
returns a named action from a given namespace.
.ie n .Sh "$self\->get_action_by_path( $path );"
.el .Sh "$self\->get_action_by_path( \f(CW$path\fP );"
.IX Subsection "$self->get_action_by_path( $path );"
Returns the named action by its full private path.
.ie n .Sh "$self\->get_actions( $c\fP, \f(CW$action\fP, \f(CW$namespace )"
.el .Sh "$self\->get_actions( \f(CW$c\fP, \f(CW$action\fP, \f(CW$namespace\fP )"
.IX Subsection "$self->get_actions( $c, $action, $namespace )"
.ie n .Sh "$self\->get_containers( $namespace )"
.el .Sh "$self\->get_containers( \f(CW$namespace\fP )"
.IX Subsection "$self->get_containers( $namespace )"
Return all the action containers for a given namespace, inclusive
.Sh "$self\->uri_for_action($action, \e@captures)"
.IX Subsection "$self->uri_for_action($action, @captures)"
Takes a Catalyst::Action object and action parameters and returns a \s-1URI\s0
part such that if \f(CW$c\fR\->req\->path were this \s-1URI\s0 part, this action would be
dispatched to with \f(CW$c\fR\->req\->captures set to the supplied arrayref.
.PP
If the action object is not available for external dispatch or the dispatcher
cannot determine an appropriate \s-1URI\s0, this method will return undef.
.Sh "expand_action"
.IX Subsection "expand_action"
expand an action into a full representation of the dispatch.
mostly useful for chained, other actions will just return a
single action.
.ie n .Sh "$self\->register( $c\fP, \f(CW$action )"
.el .Sh "$self\->register( \f(CW$c\fP, \f(CW$action\fP )"
.IX Subsection "$self->register( $c, $action )"
Make sure all required dispatch types for this action are loaded, then
pass the action to our dispatch types so they can register it if required.
Also, set up the tree with the action containers.
.ie n .Sh "$self\->setup_actions( $class\fP, \f(CW$context )"
.el .Sh "$self\->setup_actions( \f(CW$class\fP, \f(CW$context\fP )"
.IX Subsection "$self->setup_actions( $class, $context )"
Loads all of the preload dispatch types, registers their actions and then
loads all of the postload dispatch types, and iterates over the tree of
actions, displaying the debug information if appropriate.
.ie n .Sh "$self\->dispatch_type( $type )"
.el .Sh "$self\->dispatch_type( \f(CW$type\fP )"
.IX Subsection "$self->dispatch_type( $type )"
Get the DispatchType object of the relevant type, i.e. passing \f(CW$type\fR of
\&\f(CW\*(C`Chained\*(C'\fR would return a Catalyst::DispatchType::Chained object (assuming
of course it's being used.)
.Sh "meta"
.IX Subsection "meta"
Provided by Moose
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
