.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Utils 3"
.TH Catalyst::Utils 3 "2010-12-03" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
Catalyst::Utils \- The Catalyst Utils
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Catalyst.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Catalyst Utilities.
.SH "METHODS"
.IX Header "METHODS"
.Sh "appprefix($class)"
.IX Subsection "appprefix($class)"
.Vb 1
\&    MyApp::Foo becomes myapp_foo
.Ve
.Sh "class2appclass($class);"
.IX Subsection "class2appclass($class);"
.Vb 2
\&    MyApp::Controller::Foo::Bar becomes MyApp
\&    My::App::Controller::Foo::Bar becomes My::App
.Ve
.Sh "class2classprefix($class);"
.IX Subsection "class2classprefix($class);"
.Vb 2
\&    MyApp::Controller::Foo::Bar becomes MyApp::Controller
\&    My::App::Controller::Foo::Bar becomes My::App::Controller
.Ve
.Sh "class2classsuffix($class);"
.IX Subsection "class2classsuffix($class);"
.Vb 1
\&    MyApp::Controller::Foo::Bar becomes Controller::Foo::Bar
.Ve
.Sh "class2env($class);"
.IX Subsection "class2env($class);"
Returns the environment name for class.
.PP
.Vb 2
\&    MyApp becomes MYAPP
\&    My::App becomes MY_APP
.Ve
.ie n .Sh "class2prefix( $class\fP, \f(CW$case );"
.el .Sh "class2prefix( \f(CW$class\fP, \f(CW$case\fP );"
.IX Subsection "class2prefix( $class, $case );"
Returns the uri prefix for a class. If case is false the prefix is converted to lowercase.
.PP
.Vb 1
\&    My::App::Controller::Foo::Bar becomes foo/bar
.Ve
.ie n .Sh "class2tempdir( $class\fP [, \f(CW$create ] );"
.el .Sh "class2tempdir( \f(CW$class\fP [, \f(CW$create\fP ] );"
.IX Subsection "class2tempdir( $class [, $create ] );"
Returns a tempdir for a class. If create is true it will try to create the path.
.PP
.Vb 2
\&    My::App becomes /tmp/my/app
\&    My::App::Controller::Foo::Bar becomes /tmp/my/app/c/foo/bar
.Ve
.Sh "home($class)"
.IX Subsection "home($class)"
Returns home directory for given class.
.ie n .Sh "prefix($class, $name);"
.el .Sh "prefix($class, \f(CW$name\fP);"
.IX Subsection "prefix($class, $name);"
Returns a prefixed action.
.PP
.Vb 1
\&    MyApp::Controller::Foo::Bar, yada becomes foo/bar/yada
.Ve
.Sh "request($uri)"
.IX Subsection "request($uri)"
Returns an HTTP::Request object for a uri.
.Sh "ensure_class_loaded($class_name, \e%opts)"
.IX Subsection "ensure_class_loaded($class_name, %opts)"
Loads the class unless it already has been loaded.
.PP
If \f(CW$opts\fR{ignore_loaded} is true always tries the require whether the package
already exists or not. Only pass this if you're either (a) sure you know the
file exists on disk or (b) have code to catch the file not found exception
that will result if it doesn't.
.ie n .Sh "merge_hashes($hashref, $hashref)"
.el .Sh "merge_hashes($hashref, \f(CW$hashref\fP)"
.IX Subsection "merge_hashes($hashref, $hashref)"
Base code to recursively merge two hashes together with right-hand precedence.
.ie n .Sh "env_value($class, $key)"
.el .Sh "env_value($class, \f(CW$key\fP)"
.IX Subsection "env_value($class, $key)"
Checks for and returns an environment value. For instance, if \f(CW$key\fR is
\&'home', then this method will check for and return the first value it finds,
looking at \f(CW$ENV\fR{\s-1MYAPP_HOME\s0} and \f(CW$ENV\fR{\s-1CATALYST_HOME\s0}.
.Sh "term_width"
.IX Subsection "term_width"
Try to guess terminal width to use with formatting of debug output
.PP
All you need to get this work, is:
.PP
1) Install Term::Size::Any, or
.PP
2) Export \f(CW$COLUMNS\fR from your shell.
.PP
(Warning to bash users: 'echo \f(CW$COLUMNS\fR' may be showing you the bash
variable, not \f(CW$ENV\fR{\s-1COLUMNS\s0}. 'export COLUMNS=$COLUMNS' and you should see
that 'env' now lists \s-1COLUMNS\s0.)
.PP
As last resort, default value of 80 chars will be used.
.Sh "resolve_namespace"
.IX Subsection "resolve_namespace"
Method which adds the namespace for plugins and actions.
.PP
.Vb 1
\&  __PACKAGE__->setup(qw(MyPlugin));
.Ve
.PP
.Vb 1
\&  # will load Catalyst::Plugin::MyPlugin
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
