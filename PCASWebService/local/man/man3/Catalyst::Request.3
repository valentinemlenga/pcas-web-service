.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::Request 3"
.TH Catalyst::Request 3 "2010-04-26" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
Catalyst::Request \- provides information about the current client request
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 35
\&    $req = $c->request;
\&    $req->action;
\&    $req->address;
\&    $req->arguments;
\&    $req->args;
\&    $req->base;
\&    $req->body;
\&    $req->body_parameters;
\&    $req->content_encoding;
\&    $req->content_length;
\&    $req->content_type;
\&    $req->cookie;
\&    $req->cookies;
\&    $req->header;
\&    $req->headers;
\&    $req->hostname;
\&    $req->input;
\&    $req->query_keywords;
\&    $req->match;
\&    $req->method;
\&    $req->param;
\&    $req->parameters;
\&    $req->params;
\&    $req->path;
\&    $req->protocol;
\&    $req->query_parameters;
\&    $req->read;
\&    $req->referer;
\&    $req->secure;
\&    $req->captures; # previously knows as snippets
\&    $req->upload;
\&    $req->uploads;
\&    $req->uri;
\&    $req->user;
\&    $req->user_agent;
.Ve
.PP
See also Catalyst, Catalyst::Request::Upload.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the Catalyst Request class, which provides an interface to data for the
current client request. The request object is prepared by Catalyst::Engine,
thus hiding the details of the particular engine implementation.
.SH "METHODS"
.IX Header "METHODS"
.Sh "$req\->action"
.IX Subsection "$req->action"
[\s-1DEPRECATED\s0] Returns the name of the requested action.
.PP
Use \f(CW\*(C`$c\->action\*(C'\fR instead (which returns a
Catalyst::Action object).
.Sh "$req\->address"
.IX Subsection "$req->address"
Returns the \s-1IP\s0 address of the client.
.Sh "$req\->arguments"
.IX Subsection "$req->arguments"
Returns a reference to an array containing the arguments.
.PP
.Vb 1
\&    print $c->request->arguments->[0];
.Ve
.PP
For example, if your action was
.PP
.Vb 1
\&    package MyApp::Controller::Foo;
.Ve
.PP
.Vb 3
\&    sub moose : Local {
\&        ...
\&    }
.Ve
.PP
and the \s-1URI\s0 for the request was \f(CW\*(C`http://.../foo/moose/bah\*(C'\fR, the string \f(CW\*(C`bah\*(C'\fR
would be the first and only argument.
.PP
Arguments get automatically URI-unescaped for you.
.Sh "$req\->args"
.IX Subsection "$req->args"
Shortcut for \*(L"arguments\*(R".
.Sh "$req\->base"
.IX Subsection "$req->base"
Contains the \s-1URI\s0 base. This will always have a trailing slash. Note that the
\&\s-1URI\s0 scheme (eg., http vs. https) must be determined through heuristics;
depending on your server configuration, it may be incorrect. See \f(CW$req\fR\->secure
for more info.
.PP
If your application was queried with the \s-1URI\s0
\&\f(CW\*(C`http://localhost:3000/some/path\*(C'\fR then \f(CW\*(C`base\*(C'\fR is \f(CW\*(C`http://localhost:3000/\*(C'\fR.
.Sh "$req\->body"
.IX Subsection "$req->body"
Returns the message body of the request, as returned by HTTP::Body: a string,
unless Content-Type is \f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR, \f(CW\*(C`text/xml\*(C'\fR, or
\&\f(CW\*(C`multipart/form\-data\*(C'\fR, in which case a File::Temp object is returned.
.Sh "$req\->body_parameters"
.IX Subsection "$req->body_parameters"
Returns a reference to a hash containing body (\s-1POST\s0) parameters. Values can
be either a scalar or an arrayref containing scalars.
.PP
.Vb 2
\&    print $c->request->body_parameters->{field};
\&    print $c->request->body_parameters->{field}->[0];
.Ve
.PP
These are the parameters from the \s-1POST\s0 part of the request, if any.
.Sh "$req\->body_params"
.IX Subsection "$req->body_params"
Shortcut for body_parameters.
.Sh "$req\->content_encoding"
.IX Subsection "$req->content_encoding"
Shortcut for \f(CW$req\fR\->headers\->content_encoding.
.Sh "$req\->content_length"
.IX Subsection "$req->content_length"
Shortcut for \f(CW$req\fR\->headers\->content_length.
.Sh "$req\->content_type"
.IX Subsection "$req->content_type"
Shortcut for \f(CW$req\fR\->headers\->content_type.
.Sh "$req\->cookie"
.IX Subsection "$req->cookie"
A convenient method to access \f(CW$req\fR\->cookies.
.PP
.Vb 2
\&    $cookie  = $c->request->cookie('name');
\&    @cookies = $c->request->cookie;
.Ve
.Sh "$req\->cookies"
.IX Subsection "$req->cookies"
Returns a reference to a hash containing the cookies.
.PP
.Vb 1
\&    print $c->request->cookies->{mycookie}->value;
.Ve
.PP
The cookies in the hash are indexed by name, and the values are CGI::Simple::Cookie
objects.
.Sh "$req\->header"
.IX Subsection "$req->header"
Shortcut for \f(CW$req\fR\->headers\->header.
.Sh "$req\->headers"
.IX Subsection "$req->headers"
Returns an HTTP::Headers object containing the headers for the current request.
.PP
.Vb 1
\&    print $c->request->headers->header('X-Catalyst');
.Ve
.Sh "$req\->hostname"
.IX Subsection "$req->hostname"
Returns the hostname of the client.
.Sh "$req\->input"
.IX Subsection "$req->input"
Alias for \f(CW$req\fR\->body.
.Sh "$req\->query_keywords"
.IX Subsection "$req->query_keywords"
Contains the keywords portion of a query string, when no '=' signs are
present.
.PP
.Vb 1
\&    http://localhost/path?some+keywords
.Ve
.PP
.Vb 1
\&    $c->request->query_keywords will contain 'some keywords'
.Ve
.Sh "$req\->match"
.IX Subsection "$req->match"
This contains the matching part of a Regex action. Otherwise
it returns the same as 'action', except for default actions,
which return an empty string.
.Sh "$req\->method"
.IX Subsection "$req->method"
Contains the request method (\f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`POST\*(C'\fR, \f(CW\*(C`HEAD\*(C'\fR, etc).
.Sh "$req\->param"
.IX Subsection "$req->param"
Returns \s-1GET\s0 and \s-1POST\s0 parameters with a \s-1CGI\s0.pm\-compatible param method. This
is an alternative method for accessing parameters in \f(CW$c\fR\->req\->parameters.
.PP
.Vb 3
\&    $value  = $c->request->param( 'foo' );
\&    @values = $c->request->param( 'foo' );
\&    @params = $c->request->param;
.Ve
.PP
Like \s-1CGI\s0, and \fBunlike\fR earlier versions of Catalyst, passing multiple
arguments to this method, like this:
.PP
.Vb 1
\&    $c->request->param( 'foo', 'bar', 'gorch', 'quxx' );
.Ve
.PP
will set the parameter \f(CW\*(C`foo\*(C'\fR to the multiple values \f(CW\*(C`bar\*(C'\fR, \f(CW\*(C`gorch\*(C'\fR and
\&\f(CW\*(C`quxx\*(C'\fR. Previously this would have added \f(CW\*(C`bar\*(C'\fR as another value to \f(CW\*(C`foo\*(C'\fR
(creating it if it didn't exist before), and \f(CW\*(C`quxx\*(C'\fR as another value for
\&\f(CW\*(C`gorch\*(C'\fR.
.PP
\&\fB\s-1NOTE\s0\fR this is considered a legacy interface and care should be taken when
using it. \f(CW\*(C`scalar $c\->req\->param( 'foo' )\*(C'\fR will return only the first
\&\f(CW\*(C`foo\*(C'\fR param even if multiple are present; \f(CW\*(C`$c\->req\->param( 'foo' )\*(C'\fR will
return a list of as many are present, which can have unexpected consequences
when writing code of the form:
.PP
.Vb 4
\&    $foo->bar(
\&        a => 'b',
\&        baz => $c->req->param( 'baz' ),
\&    );
.Ve
.PP
If multiple \f(CW\*(C`baz\*(C'\fR parameters are provided this code might corrupt data or
cause a hash initialization error. For a more straightforward interface see
\&\f(CW\*(C`$c\->req\->parameters\*(C'\fR.
.Sh "$req\->parameters"
.IX Subsection "$req->parameters"
Returns a reference to a hash containing \s-1GET\s0 and \s-1POST\s0 parameters. Values can
be either a scalar or an arrayref containing scalars.
.PP
.Vb 2
\&    print $c->request->parameters->{field};
\&    print $c->request->parameters->{field}->[0];
.Ve
.PP
This is the combination of \f(CW\*(C`query_parameters\*(C'\fR and \f(CW\*(C`body_parameters\*(C'\fR.
.Sh "$req\->params"
.IX Subsection "$req->params"
Shortcut for \f(CW$req\fR\->parameters.
.Sh "$req\->path"
.IX Subsection "$req->path"
Returns the path, i.e. the part of the \s-1URI\s0 after \f(CW$req\fR\->base, for the current request.
.Sh "$req\->path_info"
.IX Subsection "$req->path_info"
Alias for path, added for compatibility with \s-1CGI\s0.
.Sh "$req\->protocol"
.IX Subsection "$req->protocol"
Returns the protocol (\s-1HTTP/1\s0.0 or \s-1HTTP/1\s0.1) used for the current request.
.Sh "$req\->query_parameters"
.IX Subsection "$req->query_parameters"
.Sh "$req\->query_params"
.IX Subsection "$req->query_params"
Returns a reference to a hash containing query string (\s-1GET\s0) parameters. Values can
be either a scalar or an arrayref containing scalars.
.PP
.Vb 2
\&    print $c->request->query_parameters->{field};
\&    print $c->request->query_parameters->{field}->[0];
.Ve
.Sh "$req\->read( [$maxlength] )"
.IX Subsection "$req->read( [$maxlength] )"
Reads a chunk of data from the request body. This method is intended to be
used in a while loop, reading \f(CW$maxlength\fR bytes on every call. \f(CW$maxlength\fR
defaults to the size of the request if not specified.
.PP
You have to set MyApp\->config(parse_on_demand => 1) to use this directly.
.Sh "$req\->referer"
.IX Subsection "$req->referer"
Shortcut for \f(CW$req\fR\->headers\->referer. Returns the referring page.
.Sh "$req\->secure"
.IX Subsection "$req->secure"
Returns true or false, indicating whether the connection is secure
(https). Note that the \s-1URI\s0 scheme (eg., http vs. https) must be determined
through heuristics, and therefore the reliablity of \f(CW$req\fR\->secure will depend
on your server configuration. If you are serving secure pages on the standard
\&\s-1SSL\s0 port (443) and/or setting the \s-1HTTPS\s0 environment variable, \f(CW$req\fR\->secure
should be valid.
.Sh "$req\->captures"
.IX Subsection "$req->captures"
Returns a reference to an array containing captured args from chained
actions or regex captures.
.PP
.Vb 1
\&    my @captures = @{ $c->request->captures };
.Ve
.Sh "$req\->snippets"
.IX Subsection "$req->snippets"
\&\f(CW\*(C`captures\*(C'\fR used to be called snippets. This is still available for backwards
compatibility, but is considered deprecated.
.Sh "$req\->upload"
.IX Subsection "$req->upload"
A convenient method to access \f(CW$req\fR\->uploads.
.PP
.Vb 3
\&    $upload  = $c->request->upload('field');
\&    @uploads = $c->request->upload('field');
\&    @fields  = $c->request->upload;
.Ve
.PP
.Vb 3
\&    for my $upload ( $c->request->upload('field') ) {
\&        print $upload->filename;
\&    }
.Ve
.Sh "$req\->uploads"
.IX Subsection "$req->uploads"
Returns a reference to a hash containing uploads. Values can be either a
Catalyst::Request::Upload object, or an arrayref of
Catalyst::Request::Upload objects.
.PP
.Vb 2
\&    my $upload = $c->request->uploads->{field};
\&    my $upload = $c->request->uploads->{field}->[0];
.Ve
.Sh "$req\->uri"
.IX Subsection "$req->uri"
Returns a \s-1URI\s0 object for the current request. Stringifies to the \s-1URI\s0 text.
.ie n .Sh "$req\->mangle_params( { key => 'value' }, $appendmode);"
.el .Sh "$req\->mangle_params( { key => 'value' }, \f(CW$appendmode\fP);"
.IX Subsection "$req->mangle_params( { key => 'value' }, $appendmode);"
Returns a hashref of parameters stemming from the current request's params,
plus the ones supplied.  Keys for which no current param exists will be
added, keys with undefined values will be removed and keys with existing
params will be replaced.  Note that you can supply a true value as the final
argument to change behavior with regards to existing parameters, appending
values rather than replacing them.
.PP
A quick example:
.PP
.Vb 3
\&  # URI query params foo=1
\&  my $hashref = $req->mangle_params({ foo => 2 });
\&  # Result is query params of foo=2
.Ve
.PP
versus append mode:
.PP
.Vb 3
\&  # URI query params foo=1
\&  my $hashref = $req->mangle_params({ foo => 2 }, 1);
\&  # Result is query params of foo=1&foo=2
.Ve
.PP
This is the code behind \f(CW\*(C`uri_with\*(C'\fR.
.Sh "$req\->uri_with( { key => 'value' } );"
.IX Subsection "$req->uri_with( { key => 'value' } );"
Returns a rewritten \s-1URI\s0 object for the current request. Key/value pairs
passed in will override existing parameters. You can remove an existing
parameter by passing in an undef value. Unmodified pairs will be
preserved.
.PP
You may also pass an optional second parameter that puts \f(CW\*(C`uri_with\*(C'\fR into
append mode:
.PP
.Vb 1
\&  $req->uri_with( { key => 'value' }, { mode => 'append' } );
.Ve
.PP
See \f(CW\*(C`mangle_params\*(C'\fR for an explanation of this behavior.
.Sh "$req\->remote_user"
.IX Subsection "$req->remote_user"
Returns the value of the \f(CW\*(C`REMOTE_USER\*(C'\fR environment variable.
.Sh "$req\->user_agent"
.IX Subsection "$req->user_agent"
Shortcut to \f(CW$req\fR\->headers\->user_agent. Returns the user agent (browser)
version string.
.Sh "meta"
.IX Subsection "meta"
Provided by Moose
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.
